:mod:`pya`
==========

.. py:module:: pya

.. autoapi-nested-parse::

   Collection of classes and functions for processing audio signals
   in python and jupyter notebooks, for synthesis, effects, analysis and plotting.



Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   backend/index.rst
   helper/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   Arecorder/index.rst
   Aserver/index.rst
   Asig/index.rst
   Aspec/index.rst
   Astft/index.rst
   Ugen/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   pya.Asig
   pya.Astft
   pya.Aspec
   pya.Aserver
   pya.Arecorder
   pya.Ugen
   pya.DummyBackend
   pya.PyAudioBackend



Functions
~~~~~~~~~

.. autoapisummary::

   pya.ampdb
   pya.dbamp
   pya.cpsmidi
   pya.midicps
   pya.linlin
   pya.clip
   pya.audio_from_file
   pya.buf_to_float
   pya.spectrum
   pya.normalize
   pya.device_info
   pya.find_device
   pya.determine_backend
   pya.startup
   pya.shutdown


.. py:class:: Asig(sig, sr=44100, label='', channels=1, cn=None)

   Audio signal class. Asig enables manipulation of audio signals in the style of numpy and more.
   Asig offer functions for plotting (via matplotlib) and playing audio (using the pya.Aserver class)

   .. attribute:: sig

      Array for the audio signal. Can be mono or multichannel.

      :type: numpy.array

   .. attribute:: sr

      Sampling rate

      :type: int

   .. attribute:: label

      A string label to give the object a unique identifier.

      :type: str

   .. attribute:: channels

      Number of channels

      :type: int

   .. attribute:: cn

      cn short for channel names is a list of string of size channels,
      to give each channel a unique name.
      channel names can be used to subset signal channels in a more readible way,
      e.g. asig[:, ['left', 'front']] subsets the left and front channels of the signal.

      :type: list of str, None

   .. attribute:: mix_mode

      used to extend numpy __setitem__() operation to frequent audio manipulations such as
      mixing, extending, boundary, replacing. Current Asig supports the mix_modes:
      bound, extend, overwrite.  mix_mode should not be set directly but is set temporarilty when using
      the .bound, .extend and .overwrite properties.

      :type: str or None

   .. attribute:: extend
      

      

   .. attribute:: bound
      

      

   .. attribute:: overwrite
      

      

   .. method:: channels(self)
      :property:


      Channel property


   .. method:: samples(self)
      :property:


      Return the length of signal in samples


   .. method:: cn(self)
      :property:


      Channel names getter


   .. method:: _load_audio_file(self, fname)


      Load audio file, and set self.sig to the signal and self.sr to the sampling rate.
      Currently support two types of audio loader: 1) Standard library for .wav, .aiff,
      and ffmpeg for other such as .mp3.

      :param fname: Path to file.
      :type fname: str


   .. method:: save_wavfile(self, fname='asig.wav', dtype='float32')


      Save signal as .wav file, return self.

      :param fname: name of the file with .wav (Default value = "asig.wav")
      :type fname: str
      :param dtype: datatype (Default value = 'float32')
      :type dtype: str


   .. method:: _set_col_names(self)



   .. method:: __getitem__(self, index)


      Accessing array elements through slicing.
          * int, get signal row asig[4];
          * slice, range and step slicing asig[4:40:2]  # from 4 to 40 every 2 samples;
          * list, subset rows, asig[[2, 4, 6]]  # pick out index 2, 4, 6 as a new asig
          * tuple, row and column specific slicing, asig[4:40, 3:5]  # from 4 to 40, channel 3 and 4
          * Time slicing (unit in seconds) using dict asig[{1:2.5}, :] creates indexing of 1s to 2.5s.
          * Channel name slicing: asig['l'] returns channel 'l' as a new mono asig. asig[['front', 'rear']], etc...
          * bool, subset channels: asig[:, [True, False]]


      :param index: Slicing argument.
      :type index: Number or slice or list or tuple or dict

      :returns: **a** -- __getitem__ returns a subset of the self based on the slicing.
      :rtype: Asig


   .. method:: x(self)
      :property:


      Extend mode: this mode allows destination sig size in assignment to be extended through setitem


   .. method:: b(self)
      :property:


      Bound mode: this mode allows to truncate a source signal in assignment to a limited destination in setitem.


   .. method:: o(self)
      :property:


      Overwrite mode: this mode cuts and replaces target selection by source signal on assignment via setitem


   .. method:: __setitem__(self, index, value)


      setitem: asig[index] = value. This allows all the methods from getitem:
          * numpy style slicing
          * string/string_list slicing for subsetting channels based on channel name self.cn
          * time slicing (unit seconds) via dict.
          * bool slicing to filter out specific channels.
      In addition, there are 4 possible modes: (referring to asig as 'dest', and value as 'src'
          1. standard pythonic way that the src und dest dimensions need to match
              asig[...] = value
          2. bound mode where src is copied up to the bounds of dest
              asig.b[...] = value
          3. extend mode where dest is dynamically extended to make space for src
              asig.x[...] = value
          4. overwrite mode where selected dest subset is replaced by specified src regardless the length.
              asig.o[...] = value

      row index:
          * list: e.g. [1,2,3,4,5,6,7,8] or [True, ..., False] (modes b and x possible)
          * int:  e.g. 0  (i.e. a single sample, so no need for extra modes)
          * slice: e.g. 100:5000:2  (can be used with all modes)
          * dict: e.g. {0.5: 2.5}   (modes o, b possible, x only if step==1, or if step==None and stop=None)

      :param index: Slicing argument.
      :type index: Number or slice or list or tuple or dict
      :param value: value to set
      :type value: Asig or numpy.ndarray or list

      :returns: **_** -- Updated asig
      :rtype: Asig


   .. method:: resample(self, target_sr=44100, rate=1, kind='linear')


      Resample signal based on interpolation, can process multichannel signals.

      :param target_sr: Target sampling rate (Default value = 44100)
      :type target_sr: int
      :param rate: Rate to speed up or slow down the audio (Default value = 1)
      :type rate: float
      :param kind: Type of interpolation (Default value = 'linear')
      :type kind: str

      :returns: **_** -- Asig with resampled signal.
      :rtype: Asig


   .. method:: play(self, rate=1, **kwargs)


      Play Asig audio via Aserver, using Aserver.default (if existing)
      kwargs are propagated to Aserver:play(onset=0, out=0)

      :param rate: Playback rate (Default value = 1)
      :type rate: float
      :param \*\*kwargs:
                         'server' : Aserver
                             Set which server to play. e.g. s = Aserver(); s.boot(); asig.play(server=s)
      :type \*\*kwargs: str

      :returns: **_** -- return self
      :rtype: Asig


   .. method:: shift_channel(self, shift=0)


      Shift signal to other channels. This is particular useful for assigning a mono signal to a specific channel.
          * shift = 0: does nothing as the same signal is being routed to the same position
          * shift > 0: shift channels of self.sig 'right', i.e. from [0,..channels-1] to channels [shift,shift+1,...]
          * shift < 0: shift channels of self.sig 'left', i.e. the first shift channels will be discarded.

      :param shift: shift channel amount (Default value = 0)
      :type shift: int

      :returns: **_** -- Rerouted asig
      :rtype: Asig


   .. method:: mono(self, blend=None)


      Mix channels to mono signal. Perform sig = np.sum(self.sig_copy * blend, axis=1)

      :param blend: list of gain for each channel as a multiplier.
                    Do nothing if signal is already mono, raise warning (Default value = None)
      :type blend: list

      :returns: **_** -- A mono Asig object
      :rtype: Asig


   .. method:: stereo(self, blend=None)


      Blend all channels of the signal to stereo. Applicable for any single-/ or multi-channel Asig.

      :param blend: Usage: For mono signal, blend=(g1, g2), the mono channel will be broadcated to left, right with g1, g2 gains.
                    For stereo signal, blend=(g1, g2), each channel is gain adjusted by g1, g2.
                    For multichannel: blend = [[list of gains for left channel], [list of gains for right channel]]
                    Default value = None, resulting in equal distribution to left and right channel
      :type blend: list or None

      .. rubric:: Example

      asig[:,['c1','c2','c3']].stereo[[1, 0.707, 0], [0, 0.707, 1]]
          mixes channel 'c1' to left, 'c2' to center and 'c3' to right channel
          of a new stereo asig. Note that for equal loudness left**2+right**2=1 should be used

      :returns: **_** -- A stereo Asig object
      :rtype: Asig


   .. method:: rewire(self, dic)


      Rewire channels to flexibly allow weighted channel permutations.

      :param dic: key = tuple of (source channel, destination channel)
                  value = amplitude gain
      :type dic: dict

      .. rubric:: Example

      {(0, 1): 0.2, (5, 0): 0.4}: rewire channel 0 to 1 with gain 0.2, and 5 to 1 with gain 2
      leaving other channels unmodified

      :returns: **_** -- Asig with rewired channels..
      :rtype: Asig


   .. method:: pan2(self, pan=0.0)


      Stereo panning of asig to a stereo output.
      Panning is based on constant power panning, see pan below
      Behavior depends on nr of channels self.channels
      * multi-channel signals (self.channels>2) are cut back to stereo and treated as
      * stereo signals (self.channels==2) are channelwise attenuated using cos(angle), sin(angle)
      * mono signals (self.channels==1) result in stereo output asigs.

      :param pan: panning between -1. (left) to 1. (right)  (Default value = 0.)
      :type pan: float

      :returns: **_** -- Asig
      :rtype: Asig


   .. method:: remove_DC(self)


      remove DC offset

      :param none:

      :returns: **_** -- channelwise DC-free Asig.
      :rtype: Asig


   .. method:: norm(self, norm=1, in_db=False, dcflag=False)


      Normalize signal

      :param norm: normalize threshold (Default value = 1)
      :type norm: float
      :param in_db: Normally, norm takes amplitude, if in_db, norm's unit is in dB.
      :type in_db: bool
      :param dcflag: If true, remove DC offset (Default value = False)
      :type dcflag: bool

      :returns: **_** -- normalized Asig.
      :rtype: Asig


   .. method:: gain(self, amp=None, db=None)


      Apply gain in amplitude or dB, only use one or the other arguments. Argument can be either a scalar
      or a list (to apply individual gain to each channel). The method returns a new asig with gain applied.

      :param amp: Amplitude (Default value = None)
      :type amp: float or None
      :param db: Decibel (Default value = None)
      :type db: float or int or None

      :returns: **_** -- Gain adjusted Asig.
      :rtype: Asig


   .. method:: rms(self, axis=0)


      Return signal's RMS

      :param axis: Axis to perform np.mean() on (Default value = 0)
      :type axis: int

      :returns: **_** -- RMS value
      :rtype: float


   .. method:: plot(self, fn=None, offset=0, scale=1, xlim=None, ylim=None, **kwargs)


      Display signal graph

      :param fn: Keyword or function (Default value = None)
      :type fn: func or None
      :param offset: Offset each channel to create a stacked view (Default value = 0)
      :type offset: int or float
      :param scale: Scale the y value (Default value = 1)
      :type scale: float
      :param xlim: x axis range (Default value = None)
      :type xlim: tuple or list
      :param ylim: y axis range (Default value = None)
      :type ylim: tuple or list
      :param \*\*kwargs: keyword arguments for matplotlib.pyplot.plot()

      :returns: **_** -- self, you can use plt.show() to display the plot.
      :rtype: Asig


   .. method:: get_duration(self)


      Return the duration in second.


   .. method:: get_times(self)


      Get time stamps for left-edge of sample-and-hold-signal


   .. method:: __eq__(self, other)


      Check if two asig objects have the same signal. But does not care about sr and others


   .. method:: __repr__(self)


      Report key attributes


   .. method:: __mul__(self, other)


      Magic method for multiplying. You can either multiply a scalar or an Asig object. If muliplying an Asig,
      you don't always need to have same size arrays as audio signals may different in length. If mix_mode
      is set to 'bound' the size is fixed to respect self. If not, the result will respect to whichever the
      bigger array is.


   .. method:: __rmul__(self, other)



   .. method:: __truediv__(self, other)


      Magic method for division. You can either divide a scalar or an Asig object.
      Use division with caution, audio signal is common to reach 0 or near, avoid zero division or extremely large result.

      If dividing an Asig, you don't always need to have same size arrays as audio signals
      may different in length. If mix_mode is set to 'bound' the size is fixed to respect self.
      If not, the result will respect to whichever the bigger array is.


   .. method:: __rtruediv__(self, other)



   .. method:: __add__(self, other)


      Magic method for adding. You can either add a scalar or an Asig object. If adding an Asig,
      you don't always need to have same size arrays as audio signals may different in length. If mix_mode
      is set to 'bound' the size is fixed to respect self. If not, the result will respect to whichever the
      bigger array is.


   .. method:: __radd__(self, other)



   .. method:: __sub__(self, other)


      Magic method for subtraction. You can either minus a scalar or an Asig object. If subtracting an Asig,
      you don't always need to have same size arrays as audio signals may different in length. If mix_mode
      is set to 'bound' the size is fixed to respect self. If not, the result will respect to whichever the
      bigger array is.


   .. method:: __rsub__(self, other)



   .. method:: find_events(self, step_dur=0.001, sil_thr=-20, evt_min_dur=0, sil_min_dur=0.1, sil_pad=[0.001, 0.1])


      Locate meaningful 'events' in the signal and create event list. Onset detection.

      :param step_dur: duration in seconds of each search step (Default value = 0.001)
      :type step_dur: float
      :param sil_thr: silent threshold in dB (Default value = -20)
      :type sil_thr: int
      :param evt_min_dur: minimum duration to be counted as an event (Default value = 0)
      :type evt_min_dur: float
      :param sil_min_dur: minimum duration to be counted as silent (Default value = 0.1)
      :type sil_min_dur: float
      :param sil_pad: this allows you to add a small duration before and after the actual
                      found event locations to the event ranges. If it is a list, you can set the padding (Default value = [0.001)
      :type sil_pad: list
      :param 0.1]:

      :returns: **_** -- This method returns self. But the list of events can be accessed through self._['events']
      :rtype: Asig


   .. method:: select_event(self, index=None, onset=None)


      This method can be called after find_event (aka onset detection).

      :param index: Index of the event (Default value = None)
      :type index: int or None
      :param onset: Onset of the event (Default value = None)
      :type onset: int or None

      :returns: **_** -- self
      :rtype: Asig


   .. method:: plot_events(self)



   .. method:: fade_in(self, dur=0.1, curve=1)


      Fade in the signal at the beginning

      :param dur: Duration in seconds to fade in (Default value = 0.1)
      :type dur: float
      :param curve: Curvature of the fader, power of the linspace function. (Default value = 1)
      :type curve: float

      :returns: **_** -- Asig, new asig with the fade in signal
      :rtype: Asig


   .. method:: fade_out(self, dur=0.1, curve=1)


      Fade out the signal at the end

      :param dur: duration in seconds to fade out (Default value = 0.1)
      :type dur: float
      :param curve: Curvature of the fader, power of the linspace function. (Default value = 1)
      :type curve: float

      :returns: **_** -- Asig, new asig with the fade out signal
      :rtype: Asig


   .. method:: iirfilter(self, cutoff_freqs, btype='bandpass', ftype='butter', order=4, filter='lfilter', rp=None, rs=None)


      iirfilter based on scipy.signal.iirfilter

      :param cutoff_freqs: Cutoff frequency or frequencies.
      :type cutoff_freqs: float or [float, float]
      :param btype: Filter type (Default value = 'bandpass')
      :type btype: str
      :param ftype: Tthe type of IIR filter. e.g. 'butter', 'cheby1', 'cheby2', 'elip', 'bessel' (Default value = 'butter')
      :type ftype: str
      :param order: Filter order (Default value = 4)
      :type order: int
      :param filter: The scipy.signal method to call when applying the filter coeffs to the signal.
                     by default it is set to scipy.signal.lfilter (one-dimensional).
      :type filter: str
      :param rp: For Chebyshev and elliptic filters, provides the maximum ripple in the passband. (dB) (Default value = None)
      :type rp: float
      :param rs: For Chebyshev and elliptic filters, provides the minimum attenuation in the stop band. (dB) (Default value = None)
      :type rs: float

      :returns: **_** -- new Asig with the filter applied. also you can access b, a coefficients by doing self._['b']
                and self._['a']
      :rtype: Asig


   .. method:: plot_freqz(self, worN, **kwargs)


      Plot the frequency response of a digital filter. Perform scipy.signal.freqz then plot the response.

      TODO
      :param worN:
      :param \*\*kwargs:


   .. method:: envelope(self, amps, ts=None, curve=1, kind='linear')


      Create an envelop and multiply by the signal.

      :param amps: Amplitude of each breaking point
      :type amps: array
      :param ts: Indices of each breaking point (Default value = None)
      :type ts: array
      :param curve: Affecting the curvature of the ramp. (Default value = 1)
      :type curve: int
      :param kind: The type of interpolation (Default value = 'linear')
      :type kind: str

      :returns: **_** -- Returns a new asig with the enveloped applied to its signal array
      :rtype: Asig


   .. method:: adsr(self, att=0, dec=0.1, sus=0.7, rel=0.1, curve=1, kind='linear')


      Create and applied a ADSR evelope to signal.

      :param att: attack (Default value = 0)
      :type att: float
      :param dec: decay (Default value = 0.1)
      :type dec: float
      :param sus: sustain (Default value = 0.7)
      :type sus: float
      :param rel: release. (Default value = 0.1)
      :type rel: float
      :param curve: affecting the curvature of the ramp. (Default value = 1)
      :type curve: int
      :param kind: The type of interpolation (Default value = 'linear')
      :type kind: str

      :returns: **_** -- returns a new asig with the enveloped applied to its signal array
      :rtype: Asig


   .. method:: window(self, win='triang', **kwargs)


      Apply windowing to self.sig

      :param win: Type of window check scipy.signal.get_window for avaiable types. (Default value = 'triang')
      :type win: str
      :param \*\*kwargs: keyword arguments for scipy.signal.get_window()

      :returns: **_** -- new asig with window applied.
      :rtype: Asig


   .. method:: window_op(self, nperseg=64, stride=32, win=None, fn='rms', pad='mirror')


      TODO add docstring

      :param nperseg: (Default value = 64)
      :param stride: (Default value = 32)
      :param win: (Default value = None)
      :param fn: (Default value = 'rms')
      :param pad: (Default value = 'mirror')


   .. method:: overlap_add(self, nperseg=64, stride_in=32, stride_out=32, jitter_in=None, jitter_out=None, win=None, pad='mirror')


      TODO

      :param nperseg: (Default value = 64)
      :param stride_in: (Default value = 32)
      :param stride_out: (Default value = 32)
      :param jitter_in: (Default value = None)
      :param jitter_out: (Default value = None)
      :param win: (Default value = None)
      :param pad: (Default value = 'mirror')


   .. method:: to_spec(self)


      Return Aspec object which is the rfft of the signal.


   .. method:: to_stft(self, **kwargs)


      Return Astft object which is the stft of the signal. Keyword arguments are the arguments for
      scipy.signal.stft().


   .. method:: plot_spectrum(self, offset=0, scale=1.0, xlim=None, **kwargs)


      Plot spectrum of the signal

      :param offset: If self.sig is multichannels, this will offset each
                     channels to create a stacked view for better viewing (Default value = 0.)
      :type offset: float
      :param scale: scale the y_axis (Default value = 1.)
      :type scale: float
      :param xlim: range of x_axis (Default value = None)
      :type xlim: tuple
      :param \*\*kwargs: keywords arguments for matplotlib.pyplot.plot()

      :returns: **_** -- self
      :rtype: Asig


   .. method:: spectrogram(self, *argv, **kvarg)


      Perform sicpy.signal.spectrogram and returns: frequencies, array of times, spectrogram


   .. method:: get_size(self)


      Return signal array shape and duration in seconds.


   .. method:: append(self, asig, amp=1)


      Apppend an asig with another. Conditions: the appended asig should have the same channels. If
      appended asig has a different sampling rate, resample it to match the orginal.

      :param asig: object to append
      :type asig: Asig
      :param amp: aplitude (Default value = 1)
      :type amp: float or int

      :returns: **_** -- Appended Asig object
      :rtype: Asig


   .. method:: add(self, sig, pos=None, amp=1, onset=None)


      Add a signal

      :param sig: Signal to add
      :type sig: asig
      :param pos: Postion to add (Default value = None)
      :type pos: int, None
      :param amp: Aplitude (Default value = 1)
      :type amp: float
      :param onset: Similar to pos but in time rather sample,
                    given a value to this will overwrite pos (Default value = None)
      :type onset: float or None

      :returns: **_** -- Asig with the added signal.
      :rtype: Asig


   .. method:: custom(self, func, **kwargs)


      custom function method. TODO add example



.. py:class:: Astft(x, sr=None, label=None, window='hann', nperseg=256, noverlap=None, nfft=None, detrend=False, return_onesided=True, boundary='zeros', padded=True, axis=-1, cn=None)

   Audio spectrogram (STFT) class, attributes refers to scipy.signal.stft. With an addition
   attribute cn being the list of channel names, and label being the name of the Asig

   .. method:: to_sig(self, **kwargs)


      Create signal from stft, i.e. perform istft, kwargs overwrite Astft values for istft

      :param \*\*kwargs:
                         optional keyboard arguments used in istft:
                             'sr', 'window', 'nperseg', 'noverlap', 'nfft', 'input_onesided', 'boundary'.
                         also convert 'sr' to 'fs' since scipy uses 'fs' as sampling frequency.
      :type \*\*kwargs: str

      :returns: **_** -- Asig
      :rtype: Asig


   .. method:: plot(self, fn=lambda x: x, ch=None, ax=None, xlim=None, ylim=None, **kwargs)


      Plot spectrogram

      :param fn: a function, by default is bypass
      :type fn: func
      :param ch: By default it is None,
      :type ch: int or str or None
      :param ax: you can assign your plot to specific axes (Default value = None)
      :type ax: matplotlib.axes
      :param xlim: x_axis range (Default value = None)
      :type xlim: tuple or list
      :param ylim: y_axis range (Default value = None)
      :type ylim: tuple or list
      :param \*\*kwargs: keyward arguments of matplotlib's pcolormesh

      :returns: **_** -- self
      :rtype: Asig


   .. method:: __repr__(self)


      Return repr(self).



.. py:class:: Aspec(x, sr=44100, label=None, cn=None)

   Audio spectrum class using rfft

   .. method:: to_sig(self)


      Convert Aspec into Asig


   .. method:: weight(self, weights, freqs=None, curve=1, kind='linear')


      TODO

      :param weights:
      :param freqs: (Default value = None)
      :param curve: (Default value = 1)
      :param kind: (Default value = 'linear')


   .. method:: plot(self, fn=np.abs, xlim=None, ylim=None, **kwargs)


      Plot spectrum

      :param fn: function for processing the rfft spectrum. (Default value = np.abs)
      :type fn: func
      :param xlim: Set x axis range (Default value = None)
      :type xlim: tuple or list or None
      :param ylim: Set y axis range (Default value = None)
      :type ylim: tuple or list or None
      :param \*\*kwargs: Keyword arguments for matplotlib.pyplot.plot()

      :returns: **_** -- self
      :rtype: Asig


   .. method:: __repr__(self)


      Return repr(self).



.. py:class:: Aserver(sr=44100, bs=None, device=None, channels=2, backend=None, **kwargs)

   Pya audio server
   Based on pyaudio, works as a FIFO style audio stream pipeline,
   allowing Asig.play() to send audio segement into the stream.

   Examples:
   -----------
   >>> from pya import *
   >>> ser = Aserver()
   >>> ser.boot()
   AServer: sr: 44100, blocksize: ...,
            Stream Active: True, Device: ...
   >>> asine = Ugen().sine()
   >>> asine.play(server=ser)
   Asig('sine'): 1 x 44100 @ 44100Hz = 1.000s cn=['0']

   .. attribute:: default
      

      

   .. method:: startup_default_server(**kwargs)
      :staticmethod:



   .. method:: shutdown_default_server()
      :staticmethod:



   .. method:: device(self)
      :property:



   .. method:: __repr__(self)


      Return repr(self).


   .. method:: get_devices(self, verbose=False)


      Return (and optionally print) available input and output device


   .. method:: set_device(self, idx, reboot=True)


      Set audio device

      :param idx: Index of the device
      :type idx: int
      :param reboot: If true the server will reboot. (Default value = True)
      :type reboot: bool


   .. method:: boot(self)


      boot Aserver = start stream, setting its callback to this callback.


   .. method:: quit(self)


      Aserver quit server: stop stream and terminate pa


   .. method:: play(self, asig, onset=0, out=0, **kwargs)


      Dispatch asigs or arrays for given onset.


   .. method:: _play_callback(self, in_data, frame_count, time_info, flag)


      callback function, called from pastream thread when data needed.


   .. method:: stop(self)



   .. method:: __del__(self)




.. py:class:: Arecorder(sr=44100, bs=256, device=None, channels=None, backend=None, **kwargs)

   Bases: :class:`pya.Aserver`

   pya audio recorder
   Based on pyaudio, uses callbacks to save audio data
   for pyaudio signals into ASigs

   Examples:
   -----------
   >>> from pya import Arecorder
   >>> import time
   >>> ar = Arecorder().boot()
   >>> ar.record()
   >>> time.sleep(1)
   >>> ar.stop()
   >>> print(ar.recordings)  # doctest:+ELLIPSIS
   [Asig(''): ... x ... @ 44100Hz = ...

   .. method:: device(self)
      :property:



   .. method:: set_tracks(self, tracks, gains)


      Define the number of track to be recorded and their gains.

      :param tracks: A list of input channel indices. By default None (record all channels)
      :type tracks: list or numpy.ndarray
      :param gains: A list of gains in decibel. Needs to be same length as tracks.
      :type gains: list of numpy.ndarray


   .. method:: reset(self)



   .. method:: boot(self)


      boot recorder


   .. method:: _recorder_callback(self, in_data, frame_count, time_info, flag)


      Callback function during streaming.


   .. method:: record(self)


      Activate recording


   .. method:: pause(self)


      Pause the recording, but the record_buffer remains


   .. method:: stop(self)


      Stop recording, then stores the data from record_buffer into recordings


   .. method:: __repr__(self)


      Return repr(self).



.. py:class:: Ugen

   Bases: :class:`pya.Asig.Asig`

   Unit Generator for to create Asig with predefined signal

   .. method:: sine(self, freq=440, amp=1.0, dur=None, n_rows=None, sr=44100, channels=1, cn=None, label='sine')


      Generate Sine signal Asig object.

      :param freq: signal frequency (Default value = 440)
      :type freq: int, float
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_samples only use one of the two. (Default value = 1.0)
      :type dur: int, float
      :param num_samples: number of sample. dur and num_samples only use one of the two(Default value = None)
      :type num_samples: int
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "sine")
      :type label: string

      :returns:
      :rtype: Asig object


   .. method:: cos(self, freq=440, amp=1.0, dur=None, n_rows=None, sr=44100, channels=1, cn=None, label='cosine')


      Generate Cosine signal Asig object.

      :param freq: signal frequency (Default value = 440)
      :type freq: int, float
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_samples only use one of the two. (Default value = 1.0)
      :type dur: int, float
      :param num_samples: number of sample. dur and num_samples only use one of the two(Default value = None)
      :type num_samples: int
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "cosine")
      :type label: string

      :returns:
      :rtype: Asig object


   .. method:: square(self, freq=440, amp=1.0, dur=None, n_rows=None, duty=0.5, sr=44100, sample_shift=0.5, channels=1, cn=None, label='square')


      Generate square wave signal Asig object.

      :param freq: signal frequency (Default value = 440)
      :type freq: int, float
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_samples only use one of the two. (Default value = 1.0)
      :type dur: int, float
      :param num_samples: number of sample. dur and num_samples only use one of the two(Default value = None)
      :type num_samples: int
      :param duty: duty cycle (Default value = 0.4)
      :type duty: float
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "square")
      :type label: string

      :returns:
      :rtype: Asig object


   .. method:: sawtooth(self, freq=440, amp=1.0, dur=None, n_rows=None, width=1.0, sr=44100, channels=1, cn=None, label='sawtooth')


      Generate sawtooth wave signal Asig object.

      :param freq: signal frequency (Default value = 440)
      :type freq: int, float
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_samples only use one of the two. (Default value = 1.0)
      :type dur: int, float
      :param num_samples: number of sample. dur and num_samples only use one of the two(Default value = None)
      :type num_samples: int
      :param width: tooth width (Default value = 1.0)
      :type width: float
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "sawtooth")
      :type label: string

      :returns:
      :rtype: Asig object


   .. method:: noise(self, type='white', amp=1.0, dur=None, n_rows=None, sr=44100, channels=1, cn=None, label='noise')


      Generate noise signal Asig object.

      :param type: type of noise, currently available: 'white' and 'pink' (Default value = 'white')
      :type type: string
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_samples only use one of the two. (Default value = 1.0)
      :type dur: int, float
      :param num_samples: number of sample. dur and num_samples only use one of the two(Default value = None)
      :type num_samples: int
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "square")
      :type label: string

      :returns:
      :rtype: Asig object



.. function:: ampdb(amp)

   Convert amplitude to db


.. function:: dbamp(db)

   Convert db to amplitude


.. function:: cpsmidi(c)

   Convert cycle per second into midi number


.. function:: midicps(m)

   Convert midi number into cycle per second


.. function:: linlin(x, smi, sma, dmi, dma)

   Linear mapping

   :param x: input value
   :type x: float
   :param smi: input range's minimum
   :type smi: float
   :param sma: input range's maximum
   :type sma: float
   :param dmi: input range's minimum
   :type dmi: float
   :param dma:

   :returns: **_** -- mapped output
   :rtype: float


.. function:: clip(value, minimum=-float('inf'), maximum=float('inf'))

   Signal hard clipping


.. function:: audio_from_file(path, dtype=np.float32)

   Load an audio buffer using audioread.
   This loads one block at a time, and then concatenates the results.


.. function:: buf_to_float(x, n_bytes=2, dtype=np.float32)

   Convert an integer buffer to floating point values.
   This is primarily useful when loading integer-valued wav data
   into numpy arrays.
   .. seealso:: :func:`buf_to_float`

   :param x: The integer-valued data buffer
   :type x: np.ndarray [dtype=int]
   :param n_bytes: The number of bytes per sample in `x`
   :type n_bytes: int [1, 2, 4]
   :param dtype: The target output type (default: 32-bit float)
   :type dtype: numeric type

   :returns: **x_float** -- The input data buffer cast to floating point
   :rtype: np.ndarray [dtype=float]


.. function:: spectrum(sig, samples, channels, sr)

   Return spectrum of a given signal. This method return spectrum matrix if input signal is multi-channels.

   :param sig: signal array
   :type sig: numpy.ndarray
   :param samples: total amount of samples
   :type samples: int
   :param channels: signal channels
   :type channels: int
   :param sr: sampling rate
   :type sr: int

   :returns: * **frq** (*numpy.ndarray*) -- frequencies
             * **Y** (*numpy.ndarray*) -- FFT of the signal.


.. function:: normalize(d)

   Return the normalized input array


.. function:: device_info()

   Return a formatted string about available audio devices and their info


.. function:: find_device(min_input=0, min_output=0)


.. py:class:: DummyBackend(dummy_devices=None)

   Bases: :class:`pya.backend.base.BackendBase`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. attribute:: dtype
      :annotation: = float32

      

   .. attribute:: range
      :annotation: = 1

      

   .. attribute:: bs
      :annotation: = 256

      

   .. method:: get_device_count(self)



   .. method:: get_device_info_by_index(self, idx)



   .. method:: get_default_input_device_info(self)



   .. method:: get_default_output_device_info(self)



   .. method:: open(self, *args, input_flag, output_flag, rate, frames_per_buffer, channels, stream_callback=None, **kwargs)



   .. method:: process_buffer(self, buffer)



   .. method:: terminate(self)




.. py:class:: PyAudioBackend(format=pyaudio.paFloat32)

   Bases: :class:`pya.backend.base.BackendBase`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. attribute:: _boot_delay
      :annotation: = 0.5

      

   .. attribute:: bs
      :annotation: = 256

      

   .. method:: get_device_count(self)



   .. method:: get_device_info_by_index(self, idx)



   .. method:: get_default_input_device_info(self)



   .. method:: get_default_output_device_info(self)



   .. method:: open(self, rate, channels, input_flag, output_flag, frames_per_buffer, input_device_index=None, output_device_index=None, start=True, input_host_api_specific_stream_info=None, output_host_api_specific_stream_info=None, stream_callback=None)



   .. method:: process_buffer(self, buffer)



   .. method:: terminate(self)




.. function:: determine_backend(force_webaudio=False, port=8765)


.. function:: startup(**kwargs)


.. function:: shutdown(**kwargs)


